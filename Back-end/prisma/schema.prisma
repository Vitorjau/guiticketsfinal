// Prisma schema (Schema-First): Users, Tickets, Messages, Attachments, Tags, Assignment Groups
// PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  REQUESTER
  AGENT
}

enum TicketStatus {
  OPEN
  IN_PROGRESS
  WAITING
  COMPLETED
}

enum TicketPriority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

model User {
  id           String         @id @default(cuid())
  name         String
  email        String         @unique
  passwordHash String
  role         Role           @default(REQUESTER)
  gender       String?        // 'male' | 'female' | 'other' | 'prefer-not-say'
  phone        String?

  authoredTickets   Ticket[]   @relation("TicketAuthor")
  assignedTickets   Ticket[]   @relation("TicketAssignee")
  completedTickets  Ticket[]   @relation("TicketCompleter")
  messages          TicketMessage[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model AgentCode {
  id        String  @id @default(cuid())
  code      String  @unique
  used      Boolean @default(false)
  usedBy    String? // userId that used this code
  createdAt DateTime @default(now())
}

model AssignmentGroup {
  id          String  @id @default(cuid())
  key         String  @unique
  name        String
  color       String?
  description String?

  tickets     Ticket[]
}

model Ticket {
  // We store a friendly code like TCK-001 as the primary id so the FE can use it directly
  id               String         @id
  title            String
  description      String
  status           TicketStatus   @default(OPEN)
  priority         TicketPriority?
  relatedSystem    String?

  author           User           @relation("TicketAuthor", fields: [authorId], references: [id])
  authorId         String

  assignedTo       User?          @relation("TicketAssignee", fields: [assignedToId], references: [id])
  assignedToId     String?

  completedBy      User?          @relation("TicketCompleter", fields: [completedById], references: [id])
  completedById    String?

  assignmentGroup  AssignmentGroup? @relation(fields: [assignmentGroupId], references: [id])
  assignmentGroupId String?

  messages         TicketMessage[]
  attachments      Attachment[]
  tags             TicketTag[]

  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([status])
  @@index([authorId])
  @@index([assignedToId])
}

model TicketMessage {
  id        String   @id @default(cuid())
  ticket    Ticket   @relation(fields: [ticketId], references: [id])
  ticketId  String
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  String?
  authorName  String
  authorEmail String
  content     String
  isAgent     Boolean @default(false)
  createdAt   DateTime @default(now())
}

model Attachment {
  id        String   @id @default(cuid())
  ticket    Ticket   @relation(fields: [ticketId], references: [id])
  ticketId  String
  name      String
  size      Int
  mimeType  String
  url       String
}

model Tag {
  id     String    @id @default(cuid())
  name   String    @unique
  tickets TicketTag[]
}

model TicketTag {
  ticket   Ticket @relation(fields: [ticketId], references: [id])
  ticketId String
  tag      Tag    @relation(fields: [tagId], references: [id])
  tagId    String

  @@id([ticketId, tagId])
}
